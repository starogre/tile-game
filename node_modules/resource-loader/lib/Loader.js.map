{"version":3,"sources":["../src/Loader.js"],"names":["async","MAX_PROGRESS","rgxExtractUrlHash","Loader","baseUrl","concurrency","progress","loading","defaultQueryString","_beforeMiddleware","_afterMiddleware","_boundLoadResource","r","d","_loadResource","_queue","queue","pause","resources","onProgress","onError","onLoad","onStart","onComplete","add","name","url","options","cb","Array","isArray","i","length","callback","key","Error","parentResource","_prepareUrl","onAfterMiddleware","once","parent","fullChunk","progressChunk","children","eachChunk","push","pre","fn","use","reset","kill","k","res","_onLoadBinding","detach","isLoading","abort","load","chunk","_tasks","data","dispatch","resume","parsedUrl","strictMode","result","protocol","path","indexOf","lastIndexOf","charAt","hash","exec","substr","resource","dequeue","_dequeue","eachSeries","next","call","isComplete","_onLoad","_onComplete","error","idle"],"mappings":"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","file":"Loader.js","sourcesContent":["import Signal from 'mini-signals';\nimport parseUri from 'parse-uri';\nimport * as async from './async';\nimport Resource from './Resource';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w\\-]+)?$/;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\nexport default class Loader {\n    /**\n     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n     * @param {number} [concurrency=10] - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10) {\n        /**\n         * The base url for all resources loaded by this loader.\n         *\n         * @member {string}\n         */\n        this.baseUrl = baseUrl;\n\n        /**\n         * The progress percent of the loader going through the queue.\n         *\n         * @member {number}\n         */\n        this.progress = 0;\n\n        /**\n         * Loading state of the loader, true if it is currently loading resources.\n         *\n         * @member {boolean}\n         */\n        this.loading = false;\n\n        /**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         *\n         * ```js\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         * ```\n         */\n        this.defaultQueryString = '';\n\n        /**\n         * The middleware to run before loading each resource.\n         *\n         * @member {function[]}\n         */\n        this._beforeMiddleware = [];\n\n        /**\n         * The middleware to run after loading each resource.\n         *\n         * @member {function[]}\n         */\n        this._afterMiddleware = [];\n\n        /**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @private\n         * @member {function}\n         * @param {Resource} r - The resource to load\n         * @param {Function} d - The dequeue function\n         * @return {undefined}\n         */\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n\n        /**\n         * The resources waiting to be loaded.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._queue = async.queue(this._boundLoadResource, concurrency);\n\n        this._queue.pause();\n\n        /**\n         * All the resources for this loader keyed by name.\n         *\n         * @member {object<string, Resource>}\n         */\n        this.resources = {};\n\n        /**\n         * Dispatched once per loaded or errored resource.\n         *\n         * The callback looks like {@link Loader.OnProgressSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once per errored resource.\n         *\n         * The callback looks like {@link Loader.OnErrorSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onError = new Signal();\n\n        /**\n         * Dispatched once per loaded resource.\n         *\n         * The callback looks like {@link Loader.OnLoadSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onLoad = new Signal();\n\n        /**\n         * Dispatched when the loader begins to process the queue.\n         *\n         * The callback looks like {@link Loader.OnStartSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched when the queued resources all load.\n         *\n         * The callback looks like {@link Loader.OnCompleteSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * When the progress changes the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnProgressSignal\n         * @param {Loader} loader - The loader the progress is advancing on.\n         * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n         */\n\n        /**\n         * When an error occurrs the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnErrorSignal\n         * @param {Loader} loader - The loader the error happened in.\n         * @param {Resource} resource - The resource that caused the error.\n         */\n\n        /**\n         * When a load completes the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnLoadSignal\n         * @param {Loader} loader - The loader that laoded the resource.\n         * @param {Resource} resource - The resource that has completed loading.\n         */\n\n        /**\n         * When the loader starts loading resources it dispatches this callback.\n         *\n         * @memberof Loader\n         * @callback OnStartSignal\n         * @param {Loader} loader - The loader that has started loading resources.\n         */\n\n        /**\n         * When the loader completes loading resources it dispatches this callback.\n         *\n         * @memberof Loader\n         * @callback OnCompleteSignal\n         * @param {Loader} loader - The loader that has finished loading resources.\n         */\n    }\n\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     *\n     * @param {string} [name] - The name of the resource to load, if not passed the url is used.\n     * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n     * @param {object} [options] - The options for the load.\n     * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should\n     *      the data being loaded be interpreted when using XHR?\n     * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.\n     * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @param {function} [cb] - Function to call when this specific resource completes loading.\n     * @return {Loader} Returns itself.\n     */\n    add(name, url, options, cb) {\n        // special case of an array of objects or urls\n        if (Array.isArray(name)) {\n            for (let i = 0; i < name.length; ++i) {\n                this.add(name[i]);\n            }\n\n            return this;\n        }\n\n        // if an object is passed instead of params\n        if (typeof name === 'object') {\n            cb = url || name.callback || name.onComplete;\n            options = name;\n            url = name.url;\n            name = name.name || name.key || name.url;\n        }\n\n        // case where no name is passed shift all args over by one.\n        if (typeof url !== 'string') {\n            cb = options;\n            options = url;\n            url = name;\n        }\n\n        // now that we shifted make sure we have a proper url.\n        if (typeof url !== 'string') {\n            throw new Error('No url passed to add resource to loader.');\n        }\n\n        // options are optional so people might pass a function and no options\n        if (typeof options === 'function') {\n            cb = options;\n            options = null;\n        }\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource)) {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name]) {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new Resource(name, url, options);\n\n        if (typeof cb === 'function') {\n            this.resources[name].onAfterMiddleware.once(cb);\n        }\n\n        // if loading make sure to adjust progress chunks for that parent and its children\n        if (this.loading) {\n            const parent = options.parentResource;\n            const fullChunk = parent.progressChunk * (parent.children.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (parent.children.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < parent.children.length; ++i) {\n                parent.children[i].progressChunk = eachChunk;\n            }\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @method before\n     * @param {function} fn - The middleware function to register.\n     * @return {Loader} Returns itself.\n     */\n    pre(fn) {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @alias use\n     * @method after\n     * @param {function} fn - The middleware function to register.\n     * @return {Loader} Returns itself.\n     */\n    use(fn) {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return {Loader} Returns itself.\n     */\n    reset() {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources) {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding) {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading) {\n                res.abort();\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     *\n     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n     * @return {Loader} Returns itself.\n     */\n    load(cb) {\n        // register complete callback if they pass one\n        if (typeof cb === 'function') {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading) {\n            return this;\n        }\n\n        // distribute progress chunks\n        const chunk = 100 / this._queue._tasks.length;\n\n        for (let i = 0; i < this._queue._tasks.length; ++i) {\n            this._queue._tasks[i].data.progressChunk = chunk;\n        }\n\n        // update loading state\n        this.loading = true;\n\n        // notify of start\n        this.onStart.dispatch(this);\n\n        // start loading\n        this._queue.resume();\n\n        return this;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     *\n     * @private\n     * @param {string} url - The url to prepare.\n     * @return {string} The prepared url.\n     */\n    _prepareUrl(url) {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        ) {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString) {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.substr(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1) {\n                result += `&${this.defaultQueryString}`;\n            }\n            else {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     *\n     * @private\n     * @param {Resource} resource - The resource to load.\n     * @param {function} dequeue - The function to call when we need to dequeue this item.\n     */\n    _loadResource(resource, dequeue) {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        async.eachSeries(\n            this._beforeMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, () => {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () => {\n                if (resource.isComplete) {\n                    this._onLoad(resource);\n                }\n                else {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            }\n        );\n    }\n\n    /**\n     * Called once each resource has loaded.\n     *\n     * @private\n     */\n    _onComplete() {\n        this.loading = false;\n\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     *\n     * @private\n     * @param {Resource} resource - The resource that was loaded\n     */\n    _onLoad(resource) {\n        resource._onLoadBinding = null;\n\n        // run middleware, this *must* happen before dequeue so sub-assets get added properly\n        async.eachSeries(\n            this._afterMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, next);\n            },\n            () => {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress += resource.progressChunk;\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error) {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                // remove this resource from the async queue\n                resource._dequeue();\n\n                // do completion check\n                if (this._queue.idle()) {\n                    this.progress = MAX_PROGRESS;\n                    this._onComplete();\n                }\n            }\n        );\n    }\n}\n"]}